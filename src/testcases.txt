//Testing functions:

/*
//Testing computeODF

int n = 2;
int m = 4;

double** A = malloc(sizeof(double*) * n);
for(int i = 0; i < n; ++i){
	A[i] = malloc(sizeof(double) * m);
}

A[0][0] = 1;
A[0][1] = 2;
A[0][2] = 3;
A[0][3] = 4;
A[1][0] = 5;
A[1][1] = 6;
A[1][2] = 7;
A[1][3] = 8;

//A:
//	1 2 3 4
//	5 6 7 8

double* e = malloc(sizeof(double) * m);

e[0] = 1;
e[1] = 2;
e[2] = 3;
e[3] = 4;

double* out = malloc(sizeof(double) * n);

//Calculate ODF

computeODF(A,e,n,m,out);

printf("Estimated ODF\n");
for(int i = 0; i < n; ++i){
	printf("%lf\t",out[i]);
}

free(out);
free(e);
for(int i = 0; i < n; ++i){
	free(A[i]);
}
free(A);

*/

/*

//Testing calculateNormalizationConstant
//aCOL and eLEN MUST BE EQUAL


//1nT: 1 x 2
//A: 2 x 4
//e: 4 x 1


int n = 2;
int m = 4;

double** A = malloc(sizeof(double*) * n);
for(int i = 0; i < n; ++i){
	A[i] = malloc(sizeof(double) * m);
}

A[0][0] = 1;
A[0][1] = 2;
A[0][2] = 3;
A[0][3] = 4;
A[1][0] = 5;
A[1][1] = 6;
A[1][2] = 7;
A[1][3] = 8;

//A:
//	1 2 3 4
//	5 6 7 8

double* e = malloc(sizeof(double) * m);

e[0] = 1;
e[1] = 2;
e[2] = 3;
e[3] = 4;

printf("Output:\t%lf",calculateNormalizationConstant(A,e,n,m));


free(e);
for(int i = 0; i < n; ++i){
	free(A[i]);
}
free(A);

*/


/*
	//Testing getReconstructionMatrix

	//Dimensions of G: (kn) x p
		//6 x 2
	//Dimensions of H+: p x m
		//2 x 4
	//Dimensions of GH+: kn x m

	//Dimensions of out: n x m
		//2 x 4
	//Result: (In X 1kT)GH+

	int k = 3;
	int n = 2;
	int p = 2;
	int m = 4;

	double** G = malloc(sizeof(double*) * k * n);
	for(int i = 0; i < k * n; ++i){
		G[i] = malloc(sizeof(double) * p);
	}

	double** Hplus = malloc(sizeof(double*) * p);
	for(int i = 0; i < p; ++i){
		Hplus[i] = malloc(sizeof(double) * m);
	}

	double** out = malloc(sizeof(double*) * n);
	for(int i = 0; i < n; ++i){
		out[i] = malloc(sizeof(double) * m);
	}


	G[0][0] = 1;
	G[0][1] = 1;
	G[1][0] = 1;
	G[1][1] = 1;
	G[2][0] = 1;
	G[2][1] = 1;
	G[3][0] = 1;
	G[3][1] = 1;
	G[4][0] = 1;
	G[4][1] = 1;
	G[5][0] = 1;
	G[5][1] = 1;

	Hplus[0][0] = 1;
	Hplus[0][1] = 2;
	Hplus[0][2] = 3;
	Hplus[0][3] = 4;

	Hplus[1][0] = 4;
	Hplus[1][1] = 5;
	Hplus[1][2] = 6;
	Hplus[1][3] = 7;


	getReconstructionMatrix(G,Hplus,k,n,p,m,out);
	printf("Reconstruction Matrix: \n");
	for(int i = 0; i < n; ++i) {
		printf("%lf\t%lf\t%lf\t%lf\n",out[i][0],out[i][1],out[i][2],out[i][3]);
	}


	for(int i = 0; i < p; ++i){
		free(Hplus[i]);
	}
	free(Hplus);

	for(int i = 0; i < n; ++i){
		free(out[i]);
	}
	free(out);

	for(int i = 0; i < k * n; ++i){
		free(G[i]);
	}
	free(G);
*/

/*

//Testing getEquator and getRotationMat
//C = 3 x k matrix of initial equator points
//z = test direction of interest
//mat = 3 x 3 rotation matrix for the first equator point to z

int k = 4;
double** C = malloc(sizeof(double*) * 3);
for(int i = 0; i < 3; ++i){
	C[i] = malloc(sizeof(double) * k);
}

getEquator(k,C);

printf("Base Equator Points: \n");
for(int i = 0; i < k; ++i) {
	printf("%lf\t%lf\t%lf\n",C[0][i],C[1][i],C[2][i]);
}

double u[3] = {C[0][0],C[1][0],C[2][0]};
double* up = u;
double z[3] = {5,7,-1};
double* zp = z;

double** mat = malloc(sizeof(double*) * 3);
for(int i = 0; i < 3; ++i){
	mat[i] = malloc(sizeof(double) * 3);
}

getRotationMat(zp,up,mat);

printf("Rotation Matrix: \n");
for(int i = 0; i < 3; ++i){
	printf("%lf\t%lf\t%lf\n",mat[i][0],mat[i][1],mat[i][2]);
}


for(int i = 0; i < 3; ++i){
	free(C[i]);
	free(mat[i]);
}
free(C);
free(mat);

*/



/*
	//Testing getDiffusionSignal
	//q = 5 x 3
	//v = 2 x 3
	//Output: 5 x 2
	int qLen = 5;
	int vLen = 2;

	double** q = malloc(sizeof(double*) * qLen);
		for(int i = 0; i < qLen; ++i){
			q[i] = malloc(sizeof(double) * 3);
		}


	double** v = malloc(sizeof(double*) * vLen);
		for(int i = 0; i < vLen; ++i){
			v[i] = malloc(sizeof(double) * 3);
		}

	double** out = malloc(sizeof(double*) * qLen);
		for(int i = 0; i < qLen; ++i){
			out[i] = malloc(sizeof(double) * vLen);
		}



	q[0][0] = .25;
	q[0][1] = .5;
	q[0][2] = .75;
	q[1][0] = .25;
	q[1][1] = .5;
	q[1][2] = .75;
	q[2][0] = .25;
	q[2][1] = .5;
	q[2][2] = .75;
	q[3][0] = .25;
	q[3][1] = .5;
	q[3][2] = .75;
	q[4][0] = .25;
	q[4][1] = .5;
	q[4][2] = .75;

	v[0][0] = .25;
	v[0][1] = .5;
	v[0][2] = .75;
	v[1][0] = .25;
	v[1][1] = .5;
	v[1][2] = .75;

	getDiffusionSignal(q, v, qLen, vLen,out); //Out: 5 x 2

	for(int i = 0; i < qLen; ++i){
		for(int j = 0; j < vLen; ++j){
			printf("%lf   ",out[i][j]);
		}
		printf("\n");
	}


	for(int i = 0; i < qLen; ++i){
			free(q[i]);
		}
	free(q);
	for(int i = 0; i < vLen; ++i){
			free(v[i]);
		}
	free(v);

	for(int i = 0; i < qLen; ++i){
			free(out[i]);
		}
	free(out);

	*/

/*
	const int rows = 2;
	const int cols = 4;

	double** a = malloc(sizeof(double*) * rows);
	for(int i = 0; i < rows; ++i){
		a[i] = malloc(sizeof(double) * cols);
	}
	a[0][0] = 15;
	a[0][1] = 13;
	a[0][2] = 12;
	a[0][3] = 12;
	a[1][0] = 13;
	a[1][1] = 13;
	a[1][2] = 13;
	a[1][3] = 13;

	double ** X = malloc(sizeof(double*) * cols);
		for(int i = 0; i < cols; ++i){
			X[i] = malloc(sizeof(double) * rows);
		}
	pseudoInverse(a,rows,cols,X);

	printf("\nOutput:\n");
	for(int row = 0; row < 2; ++row){
		for(int col = 0; col < 4; ++col){
			printf("%lf   ",X[row][col]);
		}
		printf("\n");
	}

	for(int i = 0; i < cols; ++i){
		free(X[i]);
	}
	free(X);

	for(int i = 0; i < rows; ++i){
		free(a[i]);
	}
	free(a);
	*/
